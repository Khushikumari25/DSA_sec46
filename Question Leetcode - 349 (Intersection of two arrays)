Approach (Two Pointers + Arrays):
Sort both arrays to compare elements in order.
Use two pointers i and j to traverse both arrays.
If nums1[i] == nums2[j], store the element and move both pointers.
If nums1[i] < nums2[j], move i; else move j.
Avoid storing duplicates.
Copy all stored common elements into the final result array and return it.

Reason:
Sorting makes it easier to find common elements efficiently using two pointers instead of nested loops.

Time Complexity: O(n log n + m log m) — for sorting both arrays and one linear scan.
Space Complexity: O(min(n, m)) — for storing intersection elements in a temporary array.

CODE:-

class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);

        int i = 0 ,k=0 , j= 0;

         int[] temp = new int[Math.min(nums1.length, nums2.length)];

        while (i < nums1.length && j < nums2.length) {
            if(nums1[i]== nums2[j]){
                //duplictes remove
                  if (k == 0 || temp[k - 1] != nums1[i]) {
                    temp[k++] = nums1[i];
                    
                  }
                   i++;
                   j++;

                   }else if(nums1[i] < nums2[j]){
                    i++;
                   }else{
                    j++;
                   }
            }
            int [] result = new int[k];
            for( int x = 0; x < k ; x++){
                result[x] = temp[x];

            }
            return result;
        

    }
}
